static void configModule(Project project, String moduleList, boolean includeModule, boolean isBinary = null) {
    def localProperties = new Properties()
    def localPropertiesFile = new File(project.rootDir, 'local.properties')
    if (localPropertiesFile.exists()) {
        localPropertiesFile.withReader('UTF-8') { reader ->
            localProperties.load(reader)
        }
    }
    if (!localProperties.contains("sourceModules")){
        updateSourceModules(localPropertiesFile, localProperties,  "${moduleList},")
        return
    }
//    if (!localProperties.contains("excludeModules")){
//        updateExcludeModules(localPropertiesFile, localProperties,  "${moduleName},")
//        return
//    }
    String sm = localProperties.getProperty("sourceModules")
    String em = localProperties.getProperty("excludeModules")
    if (includeModule) {
        def modules = moduleList.split(",")
        for (def moduleName in modules){
            if (isBinary && sm.contains(moduleName)) {
                sm = sm.replace("${moduleName},", "")
            } else if (!isBinary && !sm.contains(moduleName)) {
                sm = "${sm}${moduleName},"
            }
            if (em.contains(moduleName)) {
                em = em.replace("${moduleName},", "")
            }
        }
        updateSourceModules(localPropertiesFile, localProperties, sm)
        updateExcludeModules(localPropertiesFile, localProperties, em)

    } else {
        def modules = moduleList.split(",")
        for (def moduleName in modules){
            sm = sm.replace("${moduleName},", "")
            if (em.contains(moduleName)) {
                em = em.replace("${moduleName},", "")
            }
            if (!em.contains(moduleName)) {
                em = "${em}${moduleName},"
            }
        }
        updateExcludeModules(localPropertiesFile, localProperties, em)
        updateSourceModules(localPropertiesFile, localProperties, sm)
    }
}

static void updateSourceModules(File localPropertiesFile, Properties localProperties, String sm) {
    localProperties.setProperty("sourceModules", sm)
    OutputStream propertyFileOs = new FileOutputStream(localPropertiesFile)
    localProperties.store(propertyFileOs, "update modules")
    propertyFileOs.close()
}

static void updateExcludeModules(File localPropertiesFile, Properties localProperties, String em) {
    localProperties.setProperty("excludeModules", em)
    OutputStream propertyFileOs = new FileOutputStream(localPropertiesFile)
    localProperties.store(propertyFileOs, "update modules")
    propertyFileOs.close()
}

static void includeM(Project project, String moduleList, boolean isBinary) {
    configModule(project, moduleList, true, isBinary)
}

static void excludeM(Project project, String moduleList) {
    configModule(project, moduleList, false)

}

static def isWindows() {
    return System.properties['os.name'].contains('Windows');
}

task includeSourceModule {
    doLast {
        if (project.hasProperty("moduleList")) {
            def moduleList = project.getProperty("moduleList")
            includeM(project, moduleList, false)
        } else {
            throw new IllegalArgumentException("请传想要include的模块 eg. ./gradlew includeSourceModule -PmoduleList=home-myhome")
        }
    }

}
task includeBinaryModule {
    doLast {
        if (project.hasProperty("moduleList")) {
            def moduleList = project.getProperty("moduleList")
            includeM(project, moduleList, true)
        } else {
            throw new IllegalArgumentException("请传想要include的模块 eg. ./gradlew includeBinaryModule -PmoduleList=home-myhome")
        }
    }
}

task excludeModule {
    doLast {
        if (project.hasProperty("moduleList")) {
            def moduleList = project.getProperty("moduleList")
            excludeM(project, moduleList)
        } else {
            throw new IllegalArgumentException("请传想要exclude的模块 eg. ./gradlew excludeModule -PmoduleList=home-myhome")
        }
    }
}
task includeAll {
    doLast {
        def localProperties = new Properties()
        def localPropertiesFile = new File(rootDir, 'local.properties')
        if (localPropertiesFile.exists()) {
            localPropertiesFile.withReader('UTF-8') { reader ->
                localProperties.load(reader)
            }
        }
        StringBuffer sourcesb = new StringBuffer();
        gradle.ext.allModules.each { m ->
            sourcesb.append(m.simpleName);
            sourcesb.append(",");
        }
        localProperties.setProperty("sourceModules", sourcesb.toString());
        OutputStream outputstream = new FileOutputStream(localPropertiesFile);
        localProperties.store(outputstream, "update modules")

        localProperties.setProperty("excludeModules", "")
        localProperties.store(new FileOutputStream(localPropertiesFile), "update modules")
    }
}
task publishModule {
    doLast {
        if (project.hasProperty("moduleName")) {
            def moduleName = project.getProperty("moduleName")
            includeM(project, moduleName, false)
            gradle.ext.sourceModuleMap.each { name, module ->
                if (name != moduleName) {
                    exec {
                        executable "$rootDir$File.separator" + (isWindows() ? 'gradlew.bat' : 'gradlew')
                        workingDir rootDir
                        def argv = []
                        argv << "${module.sourcePath}:assemble"
                        argv << "publishToMavenLocal"
                        args = argv
                        println("command line:${commandLine}")
                    }
                }
            }
        } else {
            throw new IllegalArgumentException("请传想要publish的模块 eg. ./gradlew publishModule -PmoduleName=home-myhome")
        }
    }
}
task publishFwk {
    doFirst{
        if (gradle.ext.framworkSrcModuleMap.isEmpty()){
            println("没有framework模块")
        }
    }
    doLast {
        def ret = []
        try {
            gradle.ext.framworkSrcModuleMap.each { name, module ->
                ret += name
                exec {
                    executable "$rootDir$File.separator" + (isWindows() ? 'gradlew.bat' : 'gradlew')
                    workingDir rootDir
                    def argv = []
                    argv << "${module.sourcePath}:publishToMavenLocal"
                    args = argv
                    println("command line:${commandLine}")
                }
            }
        } catch (Exception ignored) {
            println(">>>> 出现异常没有全部发布，需要动手处理一下 !!!!!! !!!!!!")
        } finally {
            Collections.sort(ret)
            println(">>>> publish ${ret.size()} modules")
            println(">>>> ${ret}")
        }
    }
}

task publishBundle {
    doFirst{
        if (gradle.ext.bundleSrcModuleMap.isEmpty()){
            println("没有bundle模块")
        }
    }
    doLast {
        def ret = []
        try {
            gradle.ext.bundleSrcModuleMap.each { name, module ->
                ret += name
                exec {
                    executable "$rootDir$File.separator" + (isWindows() ? 'gradlew.bat' : 'gradlew')
                    workingDir rootDir
                    def argv = []
                    argv << "${module.sourcePath}:publishToMavenLocal"
                    args = argv
                    println("command line:${commandLine}")
                }
            }
        } catch (Exception ignored) {
            println(">>>> 出现异常没有全部发布，需要动手处理一下 !!!!!! !!!!!!")
        } finally {
            Collections.sort(ret)
            println(">>>> publish ${ret.size()} modules")
            println(">>>> ${ret}")
        }
    }
}
/**
 *
 * 模块之间的依赖关系如下
 *        app__
 /   \
 b1     b2
 \     /
 loader
 /  \
 image net ...
 \     /
 common
 * 优化发布：当common模块被编译就将其发布到本地maven，然后再并发编译image net 等模块这个过程集成的是common二进制组件，在本地maven，然后再编译loader，打包出一个供上传使用的包
 */
def assemble = getTasksByName("assembleDebug", true)
task publishAll(dependsOn:[includeAll,assemble,publishFwk,publishBundle])


task buildBigApp {
    doLast {
        exec {
            executable "$rootDir$File.separator" + (isWindows() ? 'gradlew.bat' : 'gradlew')
            workingDir rootDir
            def argv = []
            argv << "app:assembleDebug"
            args = argv
        }
    }
}
buildBigApp.dependsOn("includeAll")

