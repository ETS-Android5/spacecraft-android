import java.util.regex.Matcher
import java.util.regex.Pattern

apply plugin: 'kotlin-android'
apply plugin: 'kotlin-kapt'
apply plugin: 'androidx.navigation.safeargs'
//apply plugin: 'androidx.navigation.safeargs.kotlin'
apply from: "${rootDir}/script/console.gradle"

android {
    compileSdkVersion Integer.parseInt(rootProject.compileSdkVersion)
    buildToolsVersion rootProject.buildToolsVersion
    defaultConfig {
        (minSdkVersion, targetSdkVersion, versionCode, versionName) = [Integer.parseInt(rootProject.minSdkVersion),
                                                                       Integer.parseInt(rootProject.targetSdkVersion),
                                                                       rootProject.versionCode, rootProject.versionName]

        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"

        vectorDrawables {
            useSupportLibrary true
        }

    }
    buildFeatures {
        viewBinding true
    }
    composeOptions {
        kotlinCompilerExtensionVersion '1.0.2'
//        kotlinCompilerVersion "1.5.10"
//        kotlinCompilerExtensionVersion "1.0.0-beta08"
    }

    kotlinOptions {
        jvmTarget = "1.8"
//        useIR = true
//        freeCompilerArgs = freeCompilerArgs + [ "-P","plugin:androidx.compose.compiler.plugins.kotlin:suppressKotlinVersionCompatibilityCheck=true"]
    }
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }
    ndkVersion '22.0.7026061'
    lintOptions {
        quiet true
        lintConfig project.file("$project.rootDir/lint.xml")
        htmlReport true
//        htmlOutput project.file("$project.rootDir/lint-report-${project.name}.html")
        xmlReport true
//        xmlOutput project.file("$project.rootDir/lint-report-${project.name}.xml")
        warningsAsErrors true
        abortOnError false
//                // Turns off checks for the issue IDs you specify.
//                disable 'TypographyFractions','TypographyQuotes'
//                // Turns on checks for the issue IDs you specify. These checks are in
//                // addition to the default lint checks.
//                enable 'RtlHardcoded','RtlCompat', 'RtlEnabled'
//                // To enable checks for only a subset of issue IDs and ignore all others,
//                // list the issue IDs with the 'check' property instead. This property overrides
//                // any issue IDs you enable or disable using the properties above.
//                checkOnly 'NewApi', 'InlinedApi'
//                // If set to true, turns off analysis progress reporting by lint.
//                quiet true
//                // if set to true (default), stops the build if errors are found.
//                abortOnError false
//                // if true, only report errors.
//                ignoreWarnings true
    }
    buildTypes {
        inhouse {
            initWith debug
        }
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }
    variantFilter { variant ->
        def flavors = variant.flavors*.name
        def buildType = variant.buildType.name
        def a = gradle.ext.activeBuildVariant.toLowerCase()
        if (!a.contains(buildType)) {
            setIgnore(true)
        }
        for (def flavor in flavors) {
            if (!a.contains(flavor)) {
                setIgnore(true)
            }
        }
    }
}
dependencies {
    implementation fileTree(dir: 'libs', include: ['*.jar'])
    /**
     * ===============================test start=============================
     */
    //    androidTestImplementation 'androidx.multidex:multidex-instrumentation:2.0.0',{
//        exclude group: 'com.android.support', module: 'multidex'
//    }

    // Dependencies for local unit tests
    testImplementation 'junit:junit:4.12'
//    testImplementation "org.mockito:mockito-all:1.10.19"
//    testImplementation "org.mockito:mockito-core:${rootProject.ext.mockitoVersion}"
//    testImplementation "org.mockito:mockito-inline:${rootProject.ext.mockitoVersion}"
//    testImplementation "org.hamcrest:hamcrest-all:${rootProject.ext.hamcrestVersion}"

    // Espresso dependencies
    androidTestImplementation "androidx.test.espresso:espresso-core:3.1.1"
    androidTestImplementation "androidx.test.espresso:espresso-contrib:3.1.1"
    androidTestImplementation "androidx.test.espresso:espresso-intents:3.1.1"
    androidTestImplementation "androidx.test.espresso:espresso-accessibility:3.1.1"
    androidTestImplementation "androidx.test.espresso:espresso-web:3.1.1"
    androidTestImplementation "androidx.test.espresso.idling:idling-concurrent:3.1.1"
    // The following Espresso dependency can be either "implementation"
    // or "androidTestImplementation", depending on whether you want the
    // dependency to appear on your APK's compile classpath or the test APK
    // classpath.
    androidTestImplementation "androidx.test.espresso:espresso-idling-resource:3.1.1"

    // Dependencies for Android unit tests
    androidTestImplementation "junit:junit:${JUNIT_VERSION}"
    androidTestImplementation "org.mockito:mockito-android:$MOCKITO_VERSION"
    androidTestImplementation 'com.google.dexmaker:dexmaker:1.2'
    androidTestImplementation 'com.google.dexmaker:dexmaker-mockito:1.2'
    androidTestImplementation 'androidx.test.uiautomator:uiautomator-v18:2.2.0-alpha1'

    // Android Testing Support Library's runner and rules
    androidTestImplementation 'androidx.test.ext:junit:1.1.0'
    androidTestImplementation "androidx.test:runner:1.1.1"
    androidTestImplementation "androidx.test:rules:1.1.1"
    androidTestImplementation 'androidx.test:monitor:1.1.0'

    /**
     * ===============================test end=============================
     */
}
ext {
    getCurrentApplicationId = {
        def currFlavor = getCurrentFlavor()

        def outStr = ''
        android.productFlavors.all { flavor ->

            if (flavor.name == currFlavor)
                outStr = flavor.applicationId
        }

        return outStr
    }
    getCurrentVariant = {
        Gradle gradle = getGradle()
        String tskReqStr = gradle.getStartParameter().getTaskRequests().toString()

        Pattern pattern

        if (tskReqStr.contains("assemble"))
            pattern = Pattern.compile("assemble(\\w+)(Release|Debug)")
        else
            pattern = Pattern.compile("generate(\\w+)(Release|Debug)")

        Matcher matcher = pattern.matcher(tskReqStr)

        if (matcher.find()) {
            return matcher.group(2).toLowerCase()
        } else {
            println "NO MATCH FOUND"
            return ""
        }
    }
    getCurrentFlavor = {
        Gradle gradle = getGradle()
        String tskReqStr = gradle.getStartParameter().getTaskRequests().toString()

        Pattern pattern

        if (tskReqStr.contains("assemble"))
            pattern = Pattern.compile("assemble(\\w+)(Release|Debug)")
        else
            pattern = Pattern.compile("generate(\\w+)(Release|Debug)")

        Matcher matcher = pattern.matcher(tskReqStr)

        if (matcher.find())
            return matcher.group(1).toLowerCase()
        else {
            println "NO MATCH FOUND"
            return ""
        }
    }
    findModulePath = { simpleName ->
        if (gradle.ext.binaryModuleMap.containsKey(simpleName)) {
            def module = gradle.ext.binaryModuleMap[simpleName]
            if (module.binaryPath.isEmpty()) {
                throw new IllegalArgumentException("binary module 的binaryPath不能为空")
            }
            return module.binaryPath //'com.jamesfchen:box-tool:1.0.0'
        } else if (gradle.ext.sourceModuleMap.containsKey(simpleName)) {
            def module = gradle.ext.sourceModuleMap[simpleName]
            if (module.sourcePath.isEmpty()) {
                throw new IllegalArgumentException("source module 的sourcePath不能为空")
            }
            return module.sourcePath //':framework:common'
        }
        //该模块为exclude，不会进行编译不需要依赖
        return null
    }
    findDeps = { someOne ->
        def myPath
        if (someOne instanceof Project) {
            myPath = someOne.path //source path
        } else {
            myPath = someOne //binary path
        }
        def pickupModule = null
        if (isSourcePath(myPath)) {
            gradle.sourceModuleMap.each { _, m ->
                if (m.sourcePath == myPath) {
                    pickupModule = m
                    return
                }
            }
        } else {
            gradle.binaryModuleMap.each { _, m ->
                if (m.binaryPath == myPath) {
                    pickupModule = m
                    return
                }
            }
        }
        d = []
        if (pickupModule != null) {
            if (pickupModule.deps == null) return []
            pickupModule.deps.each { dep ->
                def path = findModulePath(dep)
                if (path != null) {
                    if (isSourcePath(path)) {
                        path = gradle.rootProject.findProject(path)
                    }
                    d.add(path)
                }
            }
        }
        return d

    }
    findModule = { simpleName ->
        if (gradle.ext.binaryModuleMap.containsKey(simpleName)) {
            return gradle.ext.binaryModuleMap[simpleName]
        } else if (gradle.ext.sourceModuleMap.containsKey(simpleName)) {
            return gradle.ext.sourceModuleMap[simpleName]
        }
        return null
    }
    importDeps = { def myProject, Closure closure ->
        HashSet<String> visited = new HashSet<String>()
        def deps = myProject.findDeps(myProject)
        recurImport(visited, deps, closure)
    }
    findArtifact = {
        def myGroupId = ''
        def myArtifactId = ''
        def myVersion = ''
        def moduleSimpleName = ''
        def sourcePath = ''
        def binaryPath = ''
        for (def module : gradle.ext.modules) {
            if (project.path == module.sourcePath) {
                moduleSimpleName = module.simpleName
                sourcePath = module.sourcePath
                binaryPath = module.binaryPath
                myGroupId = binaryPath.split(":")[0]
                myArtifactId = binaryPath.split(":")[1]
                myVersion = binaryPath.split(":")[2]
                break
            }
        }

        if ((moduleSimpleName == null || moduleSimpleName.isEmpty())
                || (sourcePath == null || sourcePath.isEmpty())
                || (binaryPath == null || binaryPath.isEmpty())
        ) {
            throw IllegalArgumentException("moduleSimpleName:${moduleSimpleName} :sourcePath${sourcePath} :binaryPath${binaryPath} 这些参数都要配置")
        }
        //todo:buildVariant跟随gradle.ext.activeBuildVariant变化

        return [moduleSimpleName, myGroupId, myArtifactId, myVersion,'debug']
    }
}

static boolean isSourcePath(def path) {
    return !path.contains(".")
}

void recurImport(def visited, def deps, Closure closure) {
    if (deps == null || deps.size() == 0) return
    for (def d : deps) {
        if (d instanceof Project) {
            if (!visited.add(d.path)) {
                continue
            }
        } else if (!visited.add(d)) {
            continue
        }
        recurImport(visited, closure.call(d), closure)
    }
}
