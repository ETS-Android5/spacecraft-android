## 帧率监控设计
通过监控主线程执行耗时，当超过阈值（微信认为700ms为卡顿阈值，携程认为600ms为长卡顿还可以接受，短卡顿5次发生），dump出当前线程的执行堆栈。
主要有两种方案
- 通过Printer#println方法计算dispatchMessage方法耗时(println的实参有字符串拼接会产生大量对象造成性能损耗)
- 计算两次Choreographer#postFrameCallback方法的时间差(当UI不刷新时，postFrameCallback方法还在监听，占用了cpu资源)

## 启动监控设计(app启动，页面启动)

页面监控方案
- 页面最早渲染出2个文本控件的时间(tti)
- onCreate 到 onWindowFocusChange 的时间


为了精确定位耗时函数会插桩统计所有的函数耗时,耗时函数被存放到一个long类型的数组中(7.6m)
- 含有PUT/READ FIELD指令的函数 或者 一些return i++这样简单的函数 不插桩 ；对于频繁调用的函数要配置黑名单来降低整个方案对性能的损耗
- 避免方法数暴增，给每个函数分配一个id
- 每个方法都调用System.nanoTime对性能有损耗，5ms的函数可以忽略，通过定时5ms刷新一个时间变量，然后每个方法直接读取更新过的时间变量
- 由于数据庞大，需要对数据进行整合与裁剪，并分析出一个能代表卡顿堆栈的key（遍历buffer，计算出一个调用树及每个函数的执行耗时，并对每一级中的一些相同执行函数做聚合，分析出主要耗时的那一级，作为代表卡顿堆栈的key）